/*
 * Workflowy domain model - a hierarchical outliner/note-taking application.
 *
 * Workflowy's core concept is the "Node" (the fundamental unit per the API).
 * Each node represents a single bullet point that can have children,
 * creating a hierarchical tree structure. Nodes can be completed,
 * have notes attached, and can reference other nodes via mirrors.
 *
 * The node data is split into two tables for embedding optimization:
 * - NodeContent: Fields that affect semantic embeddings (name, note, parentId)
 * - NodeMetadata: Fields that don't affect embeddings (priority, completed, collapsed)
 *
 * This split allows metadata changes (reordering, completing) without
 * triggering expensive embedding regeneration.
 */

package com.workflowy

// 'user' represents logged in Workflowy users
user User
    read
    systemTemporal
{
    userId    : String key userId maxLength(256);
    email     : String? maxLength(320);
    firstName : String? maxLength(256);
    lastName  : String? maxLength(256);
}

/*
 * NodeContent contains fields that affect semantic embeddings.
 * Changes to these fields trigger embedding regeneration.
 *
 * Fields:
 * - id: UUID string (36 characters) - the node's identity
 * - parentId: Parent node for hierarchy (affects embedding context)
 * - name: The text content of the node/bullet
 * - note: Optional description/notes attached to the node
 */
class NodeContent
    systemTemporal
{
    // Workflowy uses UUID strings for node IDs (36 characters)
    id       : String key minLength(36) maxLength(36);

    // Parent node ID for hierarchical structure (null for root nodes)
    parentId : String? private final minLength(36) maxLength(36);

    // The text content of the node/bullet
    name     : String maxLength(1_000_000);

    // Optional note/description attached to the node (can contain embedded files)
    note     : String? maxLength(100_000_000);
}

/*
 * NodeMetadata contains fields that do NOT affect semantic embeddings.
 * Changes to these fields (like priority reordering) do not trigger
 * embedding regeneration, allowing frequent updates without overhead.
 *
 * Has an independent temporal lifecycle from NodeContent.
 */
class NodeMetadata
    systemTemporal
    audited
{
    // References the NodeContent this metadata belongs to
    nodeId      : String key private final minLength(36) maxLength(36);

    // Priority/position within siblings (0 = first)
    priority    : Integer min(0);

    // Whether this node has been marked as completed
    completed   : Boolean;

    // Timestamp when the node was completed (null if not completed)
    completedAt : Instant?;

    // Whether this node is collapsed in the UI
    collapsed   : Boolean;
}

// Note: NodeEmbedding is stored separately (e.g., SQLite) rather than in H2
// because Klass doesn't have native binary type support and vector operations
// are better handled by specialized databases.

// Association: NodeMetadata belongs to NodeContent
association NodeHasMetadata
{
    content  : NodeContent[1..1] final;
    metadata : NodeMetadata[0..1] owned;

    relationship this.id == NodeMetadata.nodeId
}

// Self-referential association for parent-child hierarchy
// Note: Ordering by priority must be done in queries since priority is in NodeMetadata
association NodeHasChildren
{
    parent   : NodeContent[0..1] final;
    children : NodeContent[0..*];

    relationship this.id == NodeContent.parentId
}

/*
 * Mirror represents a link between an original node and its mirror copy.
 * Workflowy allows creating "live copies" of nodes called mirrors.
 * When you edit a mirrored node, changes appear everywhere it's mirrored.
 *
 * The direction is implicit: sourceNodeId â†’ virtualNodeId
 */
class Mirror
    systemTemporal
{
    id            : String key minLength(36) maxLength(36);
    sourceNodeId  : String private final minLength(36) maxLength(36);
    virtualNodeId : String private final minLength(36) maxLength(36);
}

association MirrorSourceNode
{
    sourceNode : NodeContent[1..1] final;
    mirrors    : Mirror[0..*];

    relationship this.id == Mirror.sourceNodeId
}

association MirrorVirtualNode
{
    virtualNode : NodeContent[1..1] final;
    asMirror    : Mirror[0..1];

    relationship this.id == Mirror.virtualNodeId
}

/*
 * SharedNode represents nodes that have been shared with other users.
 * Workflowy allows sharing specific nodes and their subtrees.
 *
 * Permission levels determine what the recipient can do.
 */
enumeration SharePermission
{
    VIEW("view"),
    EDIT("edit"),
    FULL("full"),
}

class SharedNode
    systemTemporal
{
    id         : String key minLength(36) maxLength(36);
    nodeId     : String private final minLength(36) maxLength(36);
    sharedWith : String private final maxLength(256);
    permission : SharePermission;
    shareUrl   : String? maxLength(2048);
}

association NodeHasShares
{
    node   : NodeContent[1..1] final;
    shares : SharedNode[0..*] owned;

    relationship this.id == SharedNode.nodeId
}

association SharedWithUser
{
    sharedNodes : SharedNode[0..*];
    recipient   : User[1..1] final;

    relationship this.sharedWith == User.userId
}

/*
 * Tag represents hashtags (#tag) or mentions (@tag) parsed from node text.
 * Note: Tags may not be first-class entities in Workflowy's API - they might
 * just be extracted from node name text. This is a modeling assumption.
 */
class Tag
    systemTemporal
{
    name : String key maxLength(128);
    color: String? maxLength(32);
}

class NodeTagMapping
    systemTemporal
{
    nodeId  : String key private final minLength(36) maxLength(36);
    tagName : String key private final maxLength(128);
}

association NodeHasTags
{
    node : NodeContent[1..1] final;
    tags : NodeTagMapping[0..*] owned;

    relationship this.id == NodeTagMapping.nodeId
}

association TagHasNodes
{
    nodes : NodeTagMapping[0..*];
    tag   : Tag[1..1] final;

    relationship this.tagName == Tag.name
}

/*
 * Date represents date metadata attached to nodes.
 * Workflowy supports date filtering and date-based views.
 * Dates are stored as Instants; displayed as dates when at midnight.
 */
class NodeDate
    systemTemporal
{
    id       : String key minLength(36) maxLength(36);
    nodeId   : String private final minLength(36) maxLength(36);
    dateValue: Instant;
}

association NodeHasDates
{
    node  : NodeContent[1..1] final;
    dates : NodeDate[0..*] owned;

    relationship this.id == NodeDate.nodeId
}

/*
 * DataImportTimestamp tracks the high watermark for incremental data imports.
 * Used by the ingestion pipeline to only process new backup files.
 */
class DataImportTimestamp
    systemTemporal
{
    name     : String key maxLength(64);
    timestamp: Instant;
}

// ============================================================================
// Projections
// ============================================================================

projection UserProjection on User
{
    userId    : "User userId",
    email     : "User email",
    firstName : "User firstName",
    lastName  : "User lastName",
    systemFrom: "User systemFrom",
    systemTo  : "User systemTo",
}

projection TagProjection on Tag
{
    name      : "Tag name",
    color     : "Tag color",
    systemFrom: "Tag systemFrom",
    systemTo  : "Tag systemTo",
}

projection NodeTagMappingProjection on NodeTagMapping
{
    systemFrom: "NodeTagMapping systemFrom",
    systemTo  : "NodeTagMapping systemTo",
    tag       : TagProjection,
}

projection NodeDateProjection on NodeDate
{
    id        : "NodeDate id",
    dateValue : "NodeDate dateValue",
    systemFrom: "NodeDate systemFrom",
    systemTo  : "NodeDate systemTo",
}

projection SharedNodeProjection on SharedNode
{
    id        : "SharedNode id",
    permission: "SharedNode permission",
    shareUrl  : "SharedNode shareUrl",
    recipient : UserProjection,
    systemFrom: "SharedNode systemFrom",
    systemTo  : "SharedNode systemTo",
}

projection MirrorProjection on Mirror
{
    id        : "Mirror id",
    systemFrom: "Mirror systemFrom",
    systemTo  : "Mirror systemTo",
}

// Projection for NodeContent (embedding-affecting fields)
projection NodeContentProjection on NodeContent
{
    id        : "NodeContent id",
    name      : "NodeContent name",
    note      : "NodeContent note",
    systemFrom: "NodeContent systemFrom",
    systemTo  : "NodeContent systemTo",
    parent    : NodeContentProjection,
}

// Projection for NodeMetadata (non-embedding fields)
projection NodeMetadataProjection on NodeMetadata
{
    priority    : "NodeMetadata priority",
    completed   : "NodeMetadata completed",
    completedAt : "NodeMetadata completedAt",
    collapsed   : "NodeMetadata collapsed",
    systemFrom  : "NodeMetadata systemFrom",
    systemTo    : "NodeMetadata systemTo",
    createdOn   : "NodeMetadata createdOn",
    createdBy   : UserProjection,
    lastUpdatedBy: UserProjection,
}

// Lightweight projection for listing nodes without nested data
projection NodeSummaryProjection on NodeContent
{
    id        : "NodeContent id",
    name      : "NodeContent name",
    note      : "NodeContent note",
    systemFrom: "NodeContent systemFrom",
    systemTo  : "NodeContent systemTo",
    metadata  : NodeMetadataProjection,
}

// Full projection including children and all metadata
projection NodeProjection on NodeContent
{
    id        : "NodeContent id",
    name      : "NodeContent name",
    note      : "NodeContent note",
    systemFrom: "NodeContent systemFrom",
    systemTo  : "NodeContent systemTo",
    parent    : NodeContentProjection,
    metadata  : NodeMetadataProjection,
    children  : NodeSummaryProjection,
    tags      : NodeTagMappingProjection,
    dates     : NodeDateProjection,
    shares    : SharedNodeProjection,
    mirrors   : MirrorProjection,
}

// ============================================================================
// Services - representing the Workflowy REST API endpoints
// ============================================================================

// NodeContent Resource - handles node content (embedding-affecting data)
service NodeContentResource on NodeContent
{
    // GET /api/node/{id} - Get a single node by ID
    /api/node/{id: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.id == id;
            projection  : NodeProjection;
        }

    // GET /api/children/{parentId} - List children of a node
    // Note: orderBy metadata.priority must be done at application layer (cross-association orderBy not supported)
    /api/children/{parentId: String[1..1]}
        GET
        {
            multiplicity: many;
            criteria    : this.parentId == parentId;
            projection  : NodeSummaryProjection;
        }

    // POST /api/node - Create a new node
    /api/node
        POST
        {
            multiplicity: one;
        }

    // PUT /api/node/{id}/edit - Edit node content
    /api/node/{id: String[1..1]}/edit
        PUT
        {
            multiplicity: one;
            criteria    : this.id == id;
        }

    // DELETE /api/node/{id}/remove - Delete a node
    /api/node/{id: String[1..1]}/remove
        DELETE
        {
            multiplicity: one;
            criteria    : this.id == id;
        }

    // List all nodes (paginated)
    /api/nodes
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : NodeSummaryProjection;
        }

    // List root nodes (nodes with no parent)
    // Note: orderBy metadata.priority must be done at application layer (cross-association orderBy not supported)
    /api/nodes/root
        GET
        {
            multiplicity: many;
            criteria    : this.parentId == null;
            projection  : NodeProjection;
        }

    // Search nodes by name
    /api/nodes/search?{query: String[1..1]}
        GET
        {
            multiplicity: many;
            criteria    : this.name contains query;
            projection  : NodeSummaryProjection;
        }
}

// NodeMetadata Resource - handles node metadata (non-embedding data)
service NodeMetadataResource on NodeMetadata
{
    // PUT /api/node/{nodeId}/metadata - Update node metadata
    /api/node/{nodeId: String[1..1]}/metadata
        GET
        {
            multiplicity: one;
            criteria    : this.nodeId == nodeId;
            projection  : NodeMetadataProjection;
        }
        PUT
        {
            multiplicity: one;
            criteria    : this.nodeId == nodeId;
        }

    // PUT /api/node/{nodeId}/complete - Mark node as complete
    /api/node/{nodeId: String[1..1]}/complete
        PUT
        {
            multiplicity: one;
            criteria    : this.nodeId == nodeId;
        }

    // PUT /api/node/{nodeId}/uncomplete - Mark node as incomplete
    /api/node/{nodeId: String[1..1]}/uncomplete
        PUT
        {
            multiplicity: one;
            criteria    : this.nodeId == nodeId;
        }

    // List completed nodes
    /api/nodes/completed
        GET
        {
            multiplicity: many;
            criteria    : this.completed == true;
            projection  : NodeMetadataProjection;
            orderBy     : this.completedAt descending;
        }
}

service UserResource on User
{
    /api/user/{userId: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.userId == userId;
            projection  : UserProjection;
        }
        PUT
        {
            criteria    : this.userId == userId;
        }

    /api/users
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : UserProjection;
        }
}

service TagResource on Tag
{
    /api/tag/{name: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.name == name;
            projection  : TagProjection;
        }
        PUT
        {
            criteria    : this.name == name;
        }
        DELETE
        {
            multiplicity: one;
            criteria    : this.name == name;
        }

    /api/tags
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : TagProjection;
        }
        POST
        {
            multiplicity: one;
        }
}
