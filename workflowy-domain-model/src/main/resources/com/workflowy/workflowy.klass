/*
 * Workflowy domain model - a hierarchical outliner/note-taking application.
 *
 * Workflowy's core concept is the "Node" (the fundamental unit per the API).
 * Each node represents a single bullet point that can have children,
 * creating a hierarchical tree structure. Nodes can be completed,
 * have notes attached, and can reference other nodes via mirrors.
 *
 * The node data is split into two tables for embedding optimization:
 * - NodeContent: Fields that affect semantic embeddings (name, note, parentId)
 * - NodeMetadata: Fields that don't affect embeddings (priority, completed, collapsed)
 *
 * This split allows metadata changes (reordering, completing) without
 * triggering expensive embedding regeneration.
 */

package com.workflowy

// 'user' represents logged in Workflowy users
user User
    read
    systemTemporal
{
    userId    : String key userId maxLength(256);
    email     : String? maxLength(320);
    firstName : String? maxLength(256);
    lastName  : String? maxLength(256);
}

/*
 * NodeContent contains fields that affect semantic embeddings.
 * Changes to these fields trigger embedding regeneration.
 *
 * Fields:
 * - id: UUID string (36 characters) - the node's identity
 * - parentId: Parent node for hierarchy (affects embedding context)
 * - name: The text content of the node/bullet
 * - note: Optional description/notes attached to the node
 */
class NodeContent
    systemTemporal
{
    // Workflowy uses UUID strings for node IDs (36 characters)
    id       : String key minLength(36) maxLength(36);

    // Parent node ID for hierarchical structure (null for root nodes)
    parentId : String? private final minLength(36) maxLength(36);

    // The text content of the node/bullet
    name     : String maxLength(1_000_000);

    // Optional note/description attached to the node (can contain embedded files)
    note     : String? maxLength(100_000_000);
}

/*
 * NodeMetadata contains fields that do NOT affect semantic embeddings.
 * Changes to these fields (like priority reordering) do not trigger
 * embedding regeneration, allowing frequent updates without overhead.
 *
 * Has an independent temporal lifecycle from NodeContent.
 */
class NodeMetadata
    systemTemporal
    audited
{
    // References the NodeContent this metadata belongs to
    nodeId      : String key private final minLength(36) maxLength(36);

    // Priority/position within siblings (0 = first)
    priority    : Integer min(0);

    // Whether this node has been marked as completed
    completed   : Boolean;

    // Timestamp when the node was completed (null if not completed)
    completedAt : Instant?;

    // Whether this node is collapsed in the UI
    collapsed   : Boolean;

    // Last modified timestamp from backup (lm field)
    lastModified: Instant?;

    // Display layout mode (bullets, todo, h1, h2, h3, code-block, quote-block)
    layoutMode  : String? maxLength(32);

    // Whether this node is a virtual root (from metadata.isVirtualRoot)
    virtualRoot: Boolean?;

    // Whether this node is a references root (from metadata.isReferencesRoot)
    referencesRoot: Boolean?;

    // Whether this node is included in AI chat (from metadata.ai.inChat)
    inChat      : Boolean?;

    // Whether this node is a mirror root (from metadata.mirror.isMirrorRoot)
    mirrorRoot: Boolean?;

    // Original ID for mirrored content (from metadata.originalId or metadata.mirror.originalId)
    originalId  : String? maxLength(64);

    // Changes metadata stored as JSON (from metadata.changes)
    changes     : String? maxLength(10000);
}

// Note: NodeEmbedding is stored separately (e.g., SQLite) rather than in H2
// because Klass doesn't have native binary type support and vector operations
// are better handled by specialized databases.

// Association: NodeMetadata belongs to NodeContent
association NodeHasMetadata
{
    content  : NodeContent[1..1] final;
    metadata : NodeMetadata[0..1] owned;

    relationship this.id == NodeMetadata.nodeId
}

// Self-referential association for parent-child hierarchy
// Note: Ordering by priority must be done in queries since priority is in NodeMetadata
association NodeHasChildren
{
    parent   : NodeContent[0..1] final;
    children : NodeContent[0..*];

    relationship this.id == NodeContent.parentId
}

/*
 * Mirror represents a link between an original node and its mirror copy.
 * Workflowy allows creating "live copies" of nodes called mirrors.
 * When you edit a mirrored node, changes appear everywhere it's mirrored.
 *
 * Terminology matches backup file:
 * - mirrorRootId: ID from metadata.mirror.mirrorRootIds (the original node)
 * - mirrorNodeId: The node that HAS the mirror metadata (the copy)
 * - isBacklink: true if from backlinkMirrorRootIds instead of mirrorRootIds
 */
class Mirror
    systemTemporal
{
    id           : String key minLength(36) maxLength(36);

    // The ID of the original node (from mirrorRootIds keys)
    mirrorRootId : String private final minLength(36) maxLength(36);

    // The ID of the node that is the mirror (has the mirror metadata)
    mirrorNodeId : String private final minLength(36) maxLength(36);

    // True if this came from backlinkMirrorRootIds instead of mirrorRootIds
    backlink   : Boolean;
}

// Association from the original node to its mirrors
association MirrorRootHasMirrors
{
    mirrorRoot : NodeContent[1..1] final;
    mirrors    : Mirror[0..*];

    relationship this.id == Mirror.mirrorRootId
}

// Association from the mirror node back to its Mirror record
association MirrorNodeHasMirror
{
    mirrorNode : NodeContent[1..1] final;
    asMirror   : Mirror[0..1];

    relationship this.id == Mirror.mirrorNodeId
}

/*
 * SharedNode represents nodes that have been shared with other users.
 * Workflowy allows sharing specific nodes and their subtrees.
 *
 * Permission levels determine what the recipient can do.
 */
enumeration SharePermission
{
    VIEW("view"),
    EDIT("edit"),
    FULL("full"),
}

class SharedNode
    systemTemporal
{
    id         : String key minLength(36) maxLength(36);
    nodeId     : String private final minLength(36) maxLength(36);
    sharedWith : String private final maxLength(256);
    permission : SharePermission;
    shareUrl   : String? maxLength(2048);
}

association NodeHasShares
{
    node   : NodeContent[1..1] final;
    shares : SharedNode[0..*] owned;

    relationship this.id == SharedNode.nodeId
}

association SharedWithUser
{
    sharedNodes : SharedNode[0..*];
    recipient   : User[1..1] final;

    relationship this.sharedWith == User.userId
}

/*
 * Tag represents hashtags (#tag) or mentions (@tag) parsed from node text.
 * Note: Tags may not be first-class entities in Workflowy's API - they might
 * just be extracted from node name text. This is a modeling assumption.
 */
class Tag
    systemTemporal
{
    name : String key maxLength(128);
    color: String? maxLength(32);
}

class NodeTagMapping
    systemTemporal
{
    nodeId  : String key private final minLength(36) maxLength(36);
    tagName : String key private final maxLength(128);
}

association NodeHasTags
{
    node : NodeContent[1..1] final;
    tags : NodeTagMapping[0..*] owned;

    relationship this.id == NodeTagMapping.nodeId
}

association TagHasNodes
{
    nodes : NodeTagMapping[0..*];
    tag   : Tag[1..1] final;

    relationship this.tagName == Tag.name
}

/*
 * Date represents date metadata attached to nodes.
 * Workflowy supports date filtering and date-based views.
 * Dates are stored as Instants; displayed as dates when at midnight.
 */
class NodeDate
    systemTemporal
{
    id        : String key minLength(36) maxLength(36);
    nodeId    : String private final minLength(36) maxLength(36);
    dateValue : Instant;
    root    : Boolean?;
    level     : String? maxLength(32);
    dateId    : String? maxLength(64);
    timestamp : Long?;
    value     : String? maxLength(1024);
}

association NodeHasDates
{
    node  : NodeContent[1..1] final;
    dates : NodeDate[0..*] owned;

    relationship this.id == NodeDate.nodeId
}

/*
 * NodeS3File represents S3 file attachments on nodes.
 * From backup: metadata.s3File
 */
class NodeS3File
    systemTemporal
{
    id                  : String key minLength(36) maxLength(36);
    nodeId              : String private final minLength(36) maxLength(36);

    // Whether this is a file attachment
    file              : Boolean;

    // Original filename
    fileName            : String? maxLength(1024);

    // MIME type or file extension
    fileType            : String? maxLength(128);

    // S3 folder/path
    objectFolder        : String? maxLength(1024);

    // Animation flag for GIFs
    animatedGIF       : Boolean?;

    // Image dimensions
    imageOriginalWidth  : Integer?;
    imageOriginalHeight : Integer?;
    imageOriginalPixels : Integer?;
}

association NodeHasS3File
{
    node   : NodeContent[1..1] final;
    s3File : NodeS3File[0..1] owned;

    relationship this.id == NodeS3File.nodeId
}

/*
 * VirtualRootMapping tracks virtual root references.
 * From backup: metadata.virtualRootIds (Map<String, Boolean>)
 * Maps a node to the virtual root nodes it references.
 */
class VirtualRootMapping
    systemTemporal
{
    nodeId        : String key private final minLength(36) maxLength(36);
    virtualRootId : String key private final minLength(36) maxLength(36);
}

association NodeHasVirtualRoots
{
    node         : NodeContent[1..1] final;
    virtualRoots : VirtualRootMapping[0..*] owned;

    relationship this.id == VirtualRootMapping.nodeId
}

association VirtualRootHasNodes
{
    referencingNodes : VirtualRootMapping[0..*];
    virtualRoot      : NodeContent[1..1] final;

    relationship this.virtualRootId == NodeContent.id
}

/*
 * DataImportTimestamp tracks the high watermark for incremental data imports.
 * Used by the ingestion pipeline to only process new backup files.
 */
class DataImportTimestamp
    systemTemporal
{
    name     : String key maxLength(64);
    timestamp: Instant;
}

// ============================================================================
// Projections
// ============================================================================

projection UserProjection on User
{
    userId    : "User userId",
    email     : "User email",
    firstName : "User firstName",
    lastName  : "User lastName",
    systemFrom: "User systemFrom",
    systemTo  : "User systemTo",
}

projection TagProjection on Tag
{
    name      : "Tag name",
    color     : "Tag color",
    systemFrom: "Tag systemFrom",
    systemTo  : "Tag systemTo",
}

projection NodeTagMappingProjection on NodeTagMapping
{
    systemFrom: "NodeTagMapping systemFrom",
    systemTo  : "NodeTagMapping systemTo",
    tag       : TagProjection,
}

projection NodeDateProjection on NodeDate
{
    id        : "NodeDate id",
    dateValue : "NodeDate dateValue",
    root    : "NodeDate root",
    level     : "NodeDate level",
    dateId    : "NodeDate dateId",
    timestamp : "NodeDate timestamp",
    value     : "NodeDate value",
    systemFrom: "NodeDate systemFrom",
    systemTo  : "NodeDate systemTo",
}

projection SharedNodeProjection on SharedNode
{
    id        : "SharedNode id",
    permission: "SharedNode permission",
    shareUrl  : "SharedNode shareUrl",
    recipient : UserProjection,
    systemFrom: "SharedNode systemFrom",
    systemTo  : "SharedNode systemTo",
}

projection MirrorProjection on Mirror
{
    id        : "Mirror id",
    backlink: "Mirror backlink",
    systemFrom: "Mirror systemFrom",
    systemTo  : "Mirror systemTo",
}

projection NodeS3FileProjection on NodeS3File
{
    id                  : "NodeS3File id",
    file              : "NodeS3File file",
    fileName            : "NodeS3File fileName",
    fileType            : "NodeS3File fileType",
    objectFolder        : "NodeS3File objectFolder",
    animatedGIF       : "NodeS3File animatedGIF",
    imageOriginalWidth  : "NodeS3File imageOriginalWidth",
    imageOriginalHeight : "NodeS3File imageOriginalHeight",
    imageOriginalPixels : "NodeS3File imageOriginalPixels",
    systemFrom          : "NodeS3File systemFrom",
    systemTo            : "NodeS3File systemTo",
}

// Projection for NodeContent (embedding-affecting fields)
// Must be declared before VirtualRootMappingProjection which references it
projection NodeContentProjection on NodeContent
{
    id        : "NodeContent id",
    name      : "NodeContent name",
    note      : "NodeContent note",
    systemFrom: "NodeContent systemFrom",
    systemTo  : "NodeContent systemTo",
    parent    : NodeContentProjection,
}

projection VirtualRootMappingProjection on VirtualRootMapping
{
    virtualRoot: NodeContentProjection,
    systemFrom : "VirtualRootMapping systemFrom",
    systemTo   : "VirtualRootMapping systemTo",
}

// Projection for NodeMetadata (non-embedding fields)
projection NodeMetadataProjection on NodeMetadata
{
    priority        : "NodeMetadata priority",
    completed       : "NodeMetadata completed",
    completedAt     : "NodeMetadata completedAt",
    collapsed       : "NodeMetadata collapsed",
    lastModified    : "NodeMetadata lastModified",
    layoutMode      : "NodeMetadata layoutMode",
    virtualRoot   : "NodeMetadata virtualRoot",
    referencesRoot: "NodeMetadata referencesRoot",
    inChat          : "NodeMetadata inChat",
    mirrorRoot    : "NodeMetadata mirrorRoot",
    originalId      : "NodeMetadata originalId",
    changes         : "NodeMetadata changes",
    systemFrom      : "NodeMetadata systemFrom",
    systemTo        : "NodeMetadata systemTo",
    createdOn       : "NodeMetadata createdOn",
    createdBy       : UserProjection,
    lastUpdatedBy   : UserProjection,
}

// Lightweight projection for listing nodes without nested data
projection NodeSummaryProjection on NodeContent
{
    id        : "NodeContent id",
    name      : "NodeContent name",
    note      : "NodeContent note",
    systemFrom: "NodeContent systemFrom",
    systemTo  : "NodeContent systemTo",
    metadata  : NodeMetadataProjection,
}

// Full projection including children and all metadata
projection NodeProjection on NodeContent
{
    id          : "NodeContent id",
    name        : "NodeContent name",
    note        : "NodeContent note",
    systemFrom  : "NodeContent systemFrom",
    systemTo    : "NodeContent systemTo",
    parent      : NodeContentProjection,
    metadata    : NodeMetadataProjection,
    children    : NodeSummaryProjection,
    tags        : NodeTagMappingProjection,
    dates       : NodeDateProjection,
    shares      : SharedNodeProjection,
    mirrors     : MirrorProjection,
    s3File      : NodeS3FileProjection,
    virtualRoots: VirtualRootMappingProjection,
}

// ============================================================================
// Services - representing the Workflowy REST API endpoints
// ============================================================================

// NodeContent Resource - handles node content (embedding-affecting data)
service NodeContentResource on NodeContent
{
    // GET /api/node/{id} - Get a single node by ID
    /api/node/{id: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.id == id;
            projection  : NodeProjection;
        }

    // GET /api/children/{parentId} - List children of a node
    // Note: orderBy metadata.priority must be done at application layer (cross-association orderBy not supported)
    /api/children/{parentId: String[1..1]}
        GET
        {
            multiplicity: many;
            criteria    : this.parentId == parentId;
            projection  : NodeSummaryProjection;
        }

    // POST /api/node - Create a new node
    /api/node
        POST
        {
            multiplicity: one;
        }

    // PUT /api/node/{id}/edit - Edit node content
    /api/node/{id: String[1..1]}/edit
        PUT
        {
            multiplicity: one;
            criteria    : this.id == id;
        }

    // DELETE /api/node/{id}/remove - Delete a node
    /api/node/{id: String[1..1]}/remove
        DELETE
        {
            multiplicity: one;
            criteria    : this.id == id;
        }

    // List all nodes (paginated)
    /api/nodes
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : NodeSummaryProjection;
        }

    // List root nodes (nodes with no parent)
    // Note: orderBy metadata.priority must be done at application layer (cross-association orderBy not supported)
    /api/nodes/root
        GET
        {
            multiplicity: many;
            criteria    : this.parentId == null;
            projection  : NodeProjection;
        }

    // Search nodes by name
    /api/nodes/search?{query: String[1..1]}
        GET
        {
            multiplicity: many;
            criteria    : this.name contains query;
            projection  : NodeSummaryProjection;
        }
}

// NodeMetadata Resource - handles node metadata (non-embedding data)
service NodeMetadataResource on NodeMetadata
{
    // PUT /api/node/{nodeId}/metadata - Update node metadata
    /api/node/{nodeId: String[1..1]}/metadata
        GET
        {
            multiplicity: one;
            criteria    : this.nodeId == nodeId;
            projection  : NodeMetadataProjection;
        }
        PUT
        {
            multiplicity: one;
            criteria    : this.nodeId == nodeId;
        }

    // PUT /api/node/{nodeId}/complete - Mark node as complete
    /api/node/{nodeId: String[1..1]}/complete
        PUT
        {
            multiplicity: one;
            criteria    : this.nodeId == nodeId;
        }

    // PUT /api/node/{nodeId}/uncomplete - Mark node as incomplete
    /api/node/{nodeId: String[1..1]}/uncomplete
        PUT
        {
            multiplicity: one;
            criteria    : this.nodeId == nodeId;
        }

    // List completed nodes
    /api/nodes/completed
        GET
        {
            multiplicity: many;
            criteria    : this.completed == true;
            projection  : NodeMetadataProjection;
            orderBy     : this.completedAt descending;
        }
}

service UserResource on User
{
    /api/user/{userId: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.userId == userId;
            projection  : UserProjection;
        }
        PUT
        {
            criteria    : this.userId == userId;
        }

    /api/users
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : UserProjection;
        }
}

service TagResource on Tag
{
    /api/tag/{name: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.name == name;
            projection  : TagProjection;
        }
        PUT
        {
            criteria    : this.name == name;
        }
        DELETE
        {
            multiplicity: one;
            criteria    : this.name == name;
        }

    /api/tags
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : TagProjection;
        }
        POST
        {
            multiplicity: one;
        }
}
